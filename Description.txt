
1) Цель данного проекта - создать самообучающуюся систему.

2) Функционирование системы

 Самообучающейся системе (пусть это будет ЦНС) 
 предоставляется как бы "тело", 
  т.е. набор сенсоров, эффекторов и "целевых сенсоров".
  Сенсор, целевой сенсор и эффектор - имеют действительные значения от min до max
 
 Это тело функционирует в какойто среде. 
 Строго говоря, ЦНС не различает среду и тело, для неё доступны только оперирование с сенсорами и эффекторами. 
 Да и само разделение среды и тела сделано для удобства.
 
 У системы среда/тело есть важный параметр - время. Время дискретно. 
 Каждый момент времени происходит такой цикл: 
   1) Эффектор, согласно законам среды/тела задают значения сенсоров
   2) ЦНС на основе значений сенсоров задает значения эффекторов
 
 Например: 
   1) Эффектор мышцы ноги был установлен ЦНС так, что-бы нога опускалась на землю.      
      Согласно законам тела нога опускается с заданной скоростью 
	     и за момент времени сенсор угла колени ноги увеличивается.
      Согласно законам среды нога касается земли, и соответствующий сенсор 
	     сигнализирует, что произошло касание.
   2) ЦНС получает значения сенсоров угла колени и касания земли 
       и реагирует на это изменением эффекторов. Или наоборот оставляет эффекторы в покое.
	   Допустим устанавливает эффектор мышщы ноги в состояние спокойствия.
	     
  Целью деятельности ЦНС является максимизация "целевых сенсоров". 
   Или, например, поддержание гомеостаза.

3) Внутреннее устройство ЦНС
  Каким образом ЦНС будет достигать своей цели?

  ЦНС необходимо выяснить каким-образом эффекторы влияет на сенсоры, а в конечном счете на целевой сенсор.
  Т.е. вскрыть законы среды/тела, выяснить какую последовательность действий необходимо совершить для выживания.

  Далее предлагаемое устройство ЦНС.
  ЦНС обладает памятью. Каждый момент времени ЦНС пишет показания всех эффекторов и сенсоров в память.
  Для каждого сенсора предлагается выделить "предиктор". Т.е. Такой объект, который будет предсказывать 
   показание сенсора в следующий момент времени, основываясь на текущих показателях сенсоров, эффекторов, памяти и т.д.
  ЦНС может объединять физические сенсоры, эффекторы (предикаты, целевые сенсоры и проч.) в группы, 
    добавлять виртуальные сенсоры (эффеторы и проч.), строить их иерархию. 
  Смысл предикатов в следующем: 
    В момент времени ЦНС запрашивает значения сенсоров у тела/среды. 
	Если значения предикатов и сенсоров совпадают, значит всё функционирует как надо. 
	Если же нет, то предикат работает не правильно и надо его изменять либо что-то еще.
	  Фокус внимания переключается на этот предикат/сенсор и проблема начинает решаться 
	  на том уровне на котором возникла, затем движется по иерархии вверх, пока не разрешится.
  
  ЦНС выстраивает иерархию реальных и виртуальных эффекторов для упрощения управления действиями.
  ЦНС создает алгоритмы действий или модели поведения для выживания.


4) Програмная реализация. 
 
  На https://project-cns.googlecode.com/svn/trunk лежит проект Low. 
  Проект не оформлен для ведения совместной разработки. Скорее предназначем для внутреннего использования.
  Кол-во комментариев стремится к нулю и так далее. Но кому интересно - может заглянуть.
  
  В проекте главный класс - CNS - собствено ЦНС.
  Для удобства среда и тело разделены. 
  В среду помещается некоторое количество существ (Creature) с заданным интерфейсом.
  Каждое существо наделяется ЦНС (CNS) с которым взаимодействует с тем же интерфейсом.
  Затем среда последовательно, каждый момент времени вызывает 
   функции интерфейса Creture в следующем порядке
    void DoPrediction();  //сделать прогноз сенсоров
	   на этом этапе ЦНС прогнозирует состояния сенсоров на следующий момент времени согласно 
	    текущим показаниям сенсоров, эффекторов и целевых сенсоров.

    void Advantage();     //перейти в следующий момент времени	    
		//Создание (тело) устанавливает значения своих сенсоров согласно эффекторам, которые установил ЦНС
		//Среда - вносит свои коррективы в эти сенсоры, согласно своим законам
		//Происходи переход в следующий момент времени
		

    void CheckPrediction(); //проверить прогноз сенсоров
	   //ЦНС проверяет - правилен ли прогноз
	   //и совершает другие действия до установки эффекторов

    void React();    //среагировать
	   //ЦНС реагирует, т.е. устанавливает эффекторы в нужное ей значение


  Объект класса CNS инициализируется объектом с интерфесом ICreature

  Интерфейст ICreature
  public interface ICreature
  {
    int SectionsCount();     //количество секций (подробнее о секциях - ниже)
    ISection GetSection(int index);  //получить секцию с порядковым заданным номером
       //далее функции которые использует "среда" для "управления"  "телом"	   
	void DoPrediction();  //сделать прогноз сенсоров
    void Advantage();     //перейти в следующий момент времени
    void CheckPrediction(); //проверить прогноз сенсоров
    void React();    //среагировать
  }

  Для удобства эффекторы и сенсоры поделены на секции. 
  Каждая секция может содержать произвольное число тех и других
  
  public interface ISection
  {
    string GetSectionsName();  //имя секции (для нужд дебага)
    int GetEffectorsCount();   //число эффекторов
    int GetSensorsCount();     //число сенсоров
    int GetGoalSensorsCount();  //число целевых сенсоров
    double GetEffector(int index);  //получить значение эффектора с заданным индексом
    string GetEffectorsName(int index); //получить имя эффектора с заданным индексом (для нужд дебага)
    double GetSensor(int index); //получить значение сенсора с заданным индексом
    string GetSensorsName(int index); //получить имя сенсора с заданным индексом (для нужд дебага)
    double GetGoalSensor(int index); //получить значение целевого сенсора с заданным индексом
    string GetGoalSensorsName(int index);//получить имя целевого сенсора с заданным индексом (для нужд дебага)
    
	void SetEffector(int index, double value); //установить эффектор в заданное значение
  }

  
  В программ реализован компонент BUG 
   это такой Creature, как бы жук с 4 ногами, 
   сенсором расстояния до ближайшей пищи, 
   сенсором угла поворота до ближайшей пищи,
   целевым сенсором голода,
   сенсором усталости.

   Каждая нога отдельная секция, состоящая из набора
    сенсор верхнего угла ноги 
	сенсор нижнего угла ноги 
	сенсор левого угла ноги 
	сенсор правого угла ноги 
	сенсор касания ногой земли
	первый эффектор горизонтальной мышцы 
	второй эффектор горизонтальной мышщы
	первый эффектор вертикальной мышцы 
	второй эффектор вертикальной мышщы

  
  Чем выше установлено значение эффектора, например, горизонтальной мышцы, - тем больше изменяется левый и правый угол ноги.
  Но тем быстрее нарастает усталость - там логарифмический график зависимости, 
   при малых значениях усталости почти вообще нет, при больших - чрезмерная.
  Но, голод увеличивается с постоянной скоростью, независимой от усталости, и если жук будет двигаться очень медленно - умрет от голода.
  Если очень быстро - от потери энергии.

  Эффект от первой и второй и второй мышцы на угол ноги - складывается. 
  Т.е. энергетически выгодно сгинать/разгинать ногу установив оба эффектора в среднее положение. 

  Необходимо, что-бы ЦНС научился находить оптимальный вариант.
  
  Еще там в двух ногах сенсоры и эффекторы из разные - из других секций. 
  Как бы одна нога - это одна секция - один набор эффекторов и связанных с ними сенсоров. 
  Но в двух секция это так, а в двух наборы смешаны. 
  Это необходимо, чтобы ЦНС научился использовать в прогнозировании сенсоров эффекторы из других секций. 

  Вообще повторю, секции введены для удобства, это не принципиальное деление. 
  Строить существо можно любыми наборами. Хоть и запихать все сенсоры и эффекторы в одну секцию.

  5) Текущая задача - 

  Собственно разобраться с прогнозированием. 
  Интересуют ссылки на работы, статьи, книги и т.д. Интересует ваше видение прогнозирования.
   


 
   
